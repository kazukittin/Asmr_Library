# Project: ASMR/Doujin Voice Desktop Player (MVP)

You are an expert full-stack developer specializing in Rust and React.
Please build a desktop application using Tauri v2, Rust, and React (TypeScript).

This application is a local audio player specialized for "ASMR" and "Doujin Voice" content.
Unlike standard music players, it needs to manage content by "RJ Code" (DLsite product ID) and provide an immersive visual experience.

## 1. Project Scope & Constraints (MVP)
- **Target OS:** Windows (Handle file paths with `\` correctly).
- **Target Files:** Unzipped folders only (Ignore .zip/.rar for now).
- **Metadata Strategy:** - Primary: Extract "RJ Code" (e.g., RJ123456) from folder names.
  - Fallback: If no RJ code is found, use the folder name as the title and the first image file found as the cover art.

## 2. Tech Stack
- **Frontend:** - React, TypeScript, Vite
  - Tailwind CSS (Styling)
  - Zustand (State Management)
  - TanStack Query (Async Data Fetching)
  - React Virtual (For handling large lists efficiently)
- **Backend (Rust):** - Tauri v2
  - sqlx (SQLite, with runtime migration)
  - rodio (Audio Playback)
  - spectrum-analyzer (FFT/Visualization)
  - walkdir (Recursive directory scanning)
  - reqwest & scraper (Metadata fetching)

## 3. Database Schema (SQLite)
Please create a migration file in `src-tauri/migrations` with the following schema:

```sql
CREATE TABLE works (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    rj_code TEXT UNIQUE, -- RJxxxxxx (Nullable for non-RJ works)
    title TEXT NOT NULL,
    dir_path TEXT NOT NULL,
    cover_path TEXT, -- Local path to the jacket image
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE tracks (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    work_id INTEGER NOT NULL,
    title TEXT NOT NULL,
    path TEXT NOT NULL,
    duration_sec INTEGER DEFAULT 0,
    track_number INTEGER,
    is_visible BOOLEAN DEFAULT 1, -- False if duplicate format (e.g., MP3 when WAV exists)
    FOREIGN KEY (work_id) REFERENCES works(id) ON DELETE CASCADE
);

CREATE TABLE track_progress (
    work_id INTEGER PRIMARY KEY,
    track_id INTEGER NOT NULL,
    position_sec REAL DEFAULT 0,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (work_id) REFERENCES works(id) ON DELETE CASCADE,
    FOREIGN KEY (track_id) REFERENCES tracks(id) ON DELETE CASCADE
);

CREATE TABLE app_settings (
    key TEXT PRIMARY KEY,
    value TEXT NOT NULL
);
4. Backend Implementation (Rust)
A. Directory Scanner (scanner.rs)
Use walkdir to scan a user-provided root directory.

Logic:

Detect folders containing "(RJ|BJ)\d{6,8}". Treat as a Work.

If no RJ code, but the folder contains audio files directly, treat as a Work (Fallback).

Find the best cover image (folder.jpg, cover.png, or largest image) in the folder.

Upsert data into works and tracks tables.

Handle Windows paths carefully.

B. Audio Engine (audio.rs)
Use rodio for playback.

Implement play, pause, resume, set_volume, and seek.

Visualization Logic: - Create a custom Source or tap into the stream to get audio samples.

Run FFT using spectrum-analyzer in a separate thread.

Emit the frequency data (Vec<f32>) to the frontend via tauri::emit (event: "spectrum-update") at ~30-60fps.

5. Frontend Implementation (React)
Design Theme: "Midnight Purple"
Background: Very dark gray/black (#0a0a0e, #121218).

Accent: Purple (#a855f7).

Text: Light gray/White.

Components
Sidebar: Navigation (Library, Settings).

WorkGrid: Display works with vertical aspect ratio (2:3) cover cards.

PlayerBar: - Persistent at the bottom.

Visualizer: A <canvas> element behind the controls that renders the waveform data received from Rust.

Hooks: - useAudioPlayer: Encapsulate Tauri invoke calls.

useLibrary: Fetch works from SQLite using TanStack Query.

6. Execution Steps
Please generate the project files in the following order:

Setup: Initialize dependencies in Cargo.toml (sqlx, rodio, spectrum-analyzer, walkdir, reqwest, tokio, serde, tauri-plugin-sql).

DB: Setup SQLite connection and run migrations on app startup.

Backend Logic: Implement scanner.rs and audio.rs.

Commands: Register Tauri commands in lib.rs / main.rs.

Frontend: Build the UI components and connect them to the backend.

Important: Ensure all Rust code is compatible with Tauri v2. Use anyhow for error handling.